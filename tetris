#!/bin/sh

# Tetris game written in pure sh
# 
# I tried to follow the Tetris Guideline(2009). 
# URL: [Tetris Guideline. Tetris Wiki. accessed at 2020-05-23](https://tetris.fandom.com/wiki/Tetris_Guideline)
#
# This script is based on bash-tetris (Author: Kirill Timofeev <kt97679@gmail.com>)
# Thank you!
#
# FreeBSD sh | o
# BusyBox sh | o
# Solaris sh | x
# 
# Author: IOE <fivetwothreesix@gmail.com>

set -u # non initialized variable is an error

# 2 signals are used: SIGUSR1 to decrease delay after level up and SIGUSR2 to quit
# they are sent to all instances of this script
# because of that we should process them in each instance
# in this instance we are ignoring both signals
# in shell enviroment, should Drop the SIG prefix, just input the signal name.
trap '' USR1 USR2

# Those are commands sent to controller by key press processing code
# In controller they are used as index to retrieve actual function from array
QUIT=0
RIGHT=1
LEFT=2
ROTATE=3
DOWN=4
DROP=5
HOLD=6

# The normal Fall Speed is defined here to be the time it takes a Tetrimino to fall by one line. 
# The current level of the game determines the normal Fall Speed using the following equation:
# (0.8 - ((level - 1) * 0.007))^(level-1)
FALL_SPEED_LEVEL_1=1
FALL_SPEED_LEVEL_2=0.793
FALL_SPEED_LEVEL_3=0.618
FALL_SPEED_LEVEL_4=0.473
FALL_SPEED_LEVEL_5=0.355
FALL_SPEED_LEVEL_6=0.262
FALL_SPEED_LEVEL_7=0.190
FALL_SPEED_LEVEL_8=0.135
FALL_SPEED_LEVEL_9=0.094
FALL_SPEED_LEVEL_10=0.064
FALL_SPEED_LEVEL_11=0.043
FALL_SPEED_LEVEL_12=0.028
FALL_SPEED_LEVEL_13=0.018
FALL_SPEED_LEVEL_14=0.011
FALL_SPEED_LEVEL_15=0.007

# color codes
RED=1
GREEN=2
YELLOW=3
BLUE=4
MAGENTA=5
CYAN=6
WHITE=7
ORANGE=208

# Those are Tetrimino type
O_TETORIMINO=0
I_TETORIMINO=1
T_TETORIMINO=2
L_TETORIMINO=3
J_TETORIMINO=4
S_TETORIMINO=5
Z_TETORIMINO=6

# Those are the facing
# Tetorimino has four facings
NORTH=0
EAST=1
SOUTH=2
WEST=3

# Location and size of playfield, color and border
PLAYFIELD_W=10
PLAYFIELD_H=20
PLAYFIELD_X=30
PLAYFIELD_Y=2
BORDER_COLOR=$WHITE

no_color=false   # do we use color or not
showtime=true    # controller runs while this flag is true
empty_cell=" ."  # how we draw empty cell
filled_cell="[]" # how we draw filled cell

# the queue of the next tetoriminos to be placed.
# the reference says the next six tetrimonos should be shown.
next_queue=''

# the hold queue allows the player to hold a falling tetorimino for as long as they wish.
hold_queue=''

bag=''

score=0 # score variable initialization
level=1 # level variable initialization

# screen_buffer is variable, that accumulates all screen changes
# this variable is printed in controller once per game cycle
puts() {
  screen_buffer="$screen_buffer""${1}"
}

# move cursor to (x,y) and print string
# (1,1) is upper left corner of the screen
xyprint() {
  puts "\033[${2};${1}H${3}"
}

show_cursor() {
  printf "\033[?25h"
}

hide_cursor() {
  printf "\033[?25l"
}

# foreground color
set_fg() {
  $no_color && return
  # puts "\033[3${1}m"
  puts "\033[38;5;${1}m"
}

# background color
set_bg() {
  $no_color && return
  # puts "\033[4${1}m"
  puts "\033[48;5;${1}m"
}

reset_colors() {
  puts "\033[0m"
}

set_bold() {
  puts "\033[1m"
}

# playfield is 2-dimensional array, data is stored as follows:
# a_{y,x} (y=0,...,PLAYFIELD_H-1, x=0,...,PLAYFIELD_W-1)
# each array element contains cell color value or -1 if cell is empty
redraw_playfield() {
  local x y xp yp field_cell

  x=0; y=0
  xp=PLAYFIELD_X
  while [ "$y" -lt "$PLAYFIELD_H" ]; do
    yp=$((y + PLAYFIELD_Y))
    xyprint $xp $yp ""
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      field_cell=`eval echo \\"\\$play_field_$y$x\\"`
      if [ "$field_cell" == -1 ]; then
        puts "$empty_cell"
      else
        set_fg "$field_cell"
        set_bg "$field_cell"
        puts "$filled_cell"
        reset_colors
      fi
      x=$((x + 1))
    done
    y=$((y + 1))
  done
}

# this array holds all possible pieces that can be used in the game
# each piece consists of 4 cells
# each string is sequence of relative xy coordinates for different orientations
# depending on piece symmetry there can be 1, 2, or 4 orientations
# <COLOR><NORTH><EAST><SOURTH><WEST>

# O-Tetrimino
piece_0_color="$YELLOW"
piece_0_start_x=3; piece_0_start_y=-2
piece_0_minos_0="1 0 2 0 1 1 2 1"
piece_0_minos_1="1 0 2 0 1 1 2 1"
piece_0_minos_2="1 0 2 0 1 1 2 1"
piece_0_minos_3="1 0 2 0 1 1 2 1"

# I-Tetorimino
piece_1_color="$CYAN"
piece_1_start_x=3; piece_1_start_y=-2
piece_1_minos_0="0 1 1 1 2 1 3 1"
piece_1_minos_1="2 0 2 1 2 2 2 3"
piece_1_minos_2="0 2 1 2 2 2 3 2"
piece_1_minos_3="1 0 1 1 1 2 1 3"

# T-Tetorimino
piece_2_color="$MAGENTA"
piece_2_start_x=3; piece_2_start_y=-2
piece_2_minos_0="1 0 0 1 1 1 2 1"
piece_2_minos_1="1 0 1 1 2 1 1 2"
piece_2_minos_2="0 1 1 1 2 1 1 2"
piece_2_minos_3="1 0 0 1 1 1 1 2"

# L-Tetorimino
piece_3_color="$ORANGE"
piece_3_start_x=3; piece_3_start_y=-2
piece_3_minos_0="2 0 0 1 1 1 2 1"
piece_3_minos_1="1 0 1 1 1 2 2 2"
piece_3_minos_2="0 1 1 1 2 1 0 2"
piece_3_minos_3="0 0 1 0 1 1 1 2"

# J-Tetorimino
piece_4_color="$BLUE"
piece_4_start_x=3; piece_4_start_y=-2
piece_4_minos_0="0 0 0 1 1 1 2 1"
piece_4_minos_1="1 0 2 0 1 1 1 2"
piece_4_minos_2="0 1 1 1 2 1 2 2"
piece_4_minos_3="1 0 1 1 0 2 1 2"

# S-Tetorimino
piece_5_color="$GREEN"
piece_5_start_x=3; piece_5_start_y=-2
piece_5_minos_0="1 0 2 0 0 1 1 1"
piece_5_minos_1="1 0 1 1 2 1 2 2"
piece_5_minos_2="1 1 2 1 0 2 1 2"
piece_5_minos_3="0 0 0 1 1 1 1 2"

# Z-Tetorimino
piece_6_color="$RED"
piece_6_start_x=3; piece_6_start_y=-2
piece_6_minos_0="0 0 1 0 1 1 2 1"
piece_6_minos_1="2 0 1 1 2 1 1 2"
piece_6_minos_2="0 1 1 1 1 2 2 2"
piece_6_minos_3="1 0 0 1 1 1 0 2"

put_piece() {
  # Arguments:
  #   1 - x, 2 - y, 3 - type, 4 - rotation, 5 - cell content
  
  local posx posy type rotation content lx ly x y

  # at first, we should save arguments.
  posx=${1}; posy=${2}; type=${3}; rotation=${4}; content=${5}
  shift $#

  # set minos coordinates.
  set `eval echo \\"\\$piece_"$type"_minos_"$rotation"\\"`

  # loop through tetorimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    # relative coordinates are retrieved bassed on orientation and added to absolute coordinates
    lx=$1; ly=$2
    x=$((posx + lx * 2)) # the width of cell is 2 characters thick
    y=$((posy + ly))
    xyprint $x $y "$content"
    shift 2
  done
}

fill_bag() {
  bag=$(shuf -e $O_TETORIMINO $I_TETORIMINO $T_TETORIMINO $L_TETORIMINO $J_TETORIMINO $S_TETORIMINO $Z_TETORIMINO |
  (
    while read piece; do
      printf "$piece"' '
    done
  ))
}

feed_next_queue() {
  :
}

hold_tetorimino() {
  :
}

get_next() {
  :
}

new_piece_location_ok() {
  # Arguments: 1 - new x coordinate of the piece, 2 - new y coordinate of the piece
  # test if piece can be moved to new location

  local x_test y_test x y lx ly field_cell
  x_test=${1}; y_test=${2}

  # set minos coordinates in parameters
  # $1 - x, $2 - y
  set `eval echo \\"\\$piece_"$current_tetorimino"_minos_"$current_rotation"\\"`
  lx=$1; ly=$2
  x=$((lx + x_test)) # new x coordinate of piece cell
  y=$((ly + y_test)) # new y coordinate of piece cell

  [ "$y" -lt 0 ]              || 
  [ "$y" -ge "$PLAYFIELD_H" ] || 
  [ "$x" -lt 0 ]              || 
  [ "$x" -ge "$PLAYFIELD_W" ] && return 1 # false; check if we are out of the play field

  field_cell=`eval echo \\"\\$play_field_$y$x\\"`
  [ "$field_cell" != -1 ] && return 1 # false; check if location is already occupied

  return 0

}

draw_border() {
  local x1 x2 y1 y2 i x y

  set_bold
  set_fg $BORDER_COLOR
  x1=$((PLAYFIELD_X - 1))               # 1 here is because border is 1 characters thick
  x2=$((PLAYFIELD_X + PLAYFIELD_W * 2)) # 2 here is because each cell on play field is 2 characters wide
  y1=$((PLAYFIELD_Y - 1))
  y2=$((PLAYFIELD_Y + PLAYFIELD_H))

  i=0
  while [ "$i" -lt "$PLAYFIELD_H" ]; do
    y=$((i + PLAYFIELD_Y))
    xyprint $x1 $y "│"
    xyprint $x2 $y "│"
    i=$((i + 1))
  done
  
  i=0
  while [ "$i" -lt "$PLAYFIELD_W" ]; do
    x=$((i * 2 + PLAYFIELD_X)) # 2 here is because each cell on play field is 2 characters width
    xyprint $x $y1 '──'
    xyprint $x $y2 '──'
    i=$((i + 1))
  done
  
  xyprint $x1 $y1 "┌"; xyprint $x2 $y1 "┐" # draw the corners
  xyprint $x1 $y2 "└"; xyprint $x2 $y2 "┘"

  reset_colors
}

init() {
  local x y

  # playfield is initialized with -1s (empty cells)
  x=0; y=0
  while [ "$y" -lt "$PLAYFIELD_H" ]; do
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      eval play_field_$y$x=-1
      x=$((x + 1))
    done
    y=$((y + 1))
  done

  screen_buffer=""
  clear
  hide_cursor
}

# this function runs in separate process
# it sends DOWN commands to controller with appropriate delay
ticker() {
  # on SIGUSR2 this process should exit
  trap exit USR2

  while true ; do printf $DOWN; sleep $DELAY; done
}

# this function processes keyboard input
reader() {
  trap exit USR2 # this process exits on SIGUSR2
  trap '' USR1   # SIGUSR1 is ignored
  local key a='' b='' cmd

  while : ;do
    key=$(stty -icanon; dd ibs=1 count=1 2>/dev/null)
    
    echo $key
    a=$b   # preserve previous keys
    b=$key
  done
}

# this function updated occupied cells in play_field array after piece is dropped
flatten_playfield() {
  :
}

# this function goes through play_field array and eliminates lines without empty cells
process_complete_lines() {
  :
}

process_fallen_piece() {
  :
}

move_piece() {
  # arguments: 1 - new x coordinate, 2 - new y coordinate
  # moves the piece to the new locatio if possible
  :
}

cmd_right(){
  :
}

cmd_left() {
  :
}

cmd_rotate() {
  :
}

cmd_down() {
  :
}

cmd_drop() {
  :
}

cmd_hold() {
  :
}

cmd_quit() {
  :
}

controller() {
  # SIGUSR1 and SIGUSR2 are ignored
  trap '' USR1 USR2
  
  init
  # set_fg $ORANGE
  # set_bg $ORANGE
  # put_piece 5 1 2 2 "$filled_cell"
  # reset_colors
  
  # draw_border
  # redraw_playfield
  # printf "$screen_buffer"

  # return
  while $showtime; do # run while showtime variable is true, it is changed to false in cmd_quit function
    echo "$screen_buffer"
    screen_buffer=""
    read cmd
    echo "$cmd"
  done
  
}

stty_g=`stty -g` # let's save terminal state

# output of ticker and reader is joined and piped into controller
(
  ticker & # ticker runs as separate process
  reader
)|(
  controller
)

sleep 50
wait

show_cursor
stty "$stty_g" # let's restore terminal state
