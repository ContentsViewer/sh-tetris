#!/bin/sh

# Tetris game written in pure sh
# 
# I tried to follow the Tetris Guideline(2009). 
# URL: [Tetris Guideline. Tetris Wiki. accessed at 2020-05-23](https://tetris.fandom.com/wiki/Tetris_Guideline)
#
# This script is based on bash-tetris (Author: Kirill Timofeev <kt97679@gmail.com>)
# Thank you!
#
# Linux   sh | o
# FreeBSD sh | o
# BusyBox sh | o
# Solaris sh | x
# 
# Author: IOE <Github: ContentsViewer>

set -u # non initialized variable is an error

# 2 signals are used: SIGUSR1 to decrease delay after level up and SIGUSR2 to quit
# they are sent to all instances of this script
# because of that we should process them in each instance
# in this instance we are ignoring both signals
# in shell enviroment, should Drop the SIG prefix, just input the signal name.
trap '' USR1 USR2

# Those are commands sent to controller by key press processing code
# In controller they are used as index to retrieve actual function from array
QUIT=0
RIGHT=1
LEFT=2
FALL=3
SOFT_DROP=4
HARD_DROP=5
ROTATE_CW=6
ROTATE_CCW=7
HOLD=8
TOGGLE_COLOR=9

# The normal Fall Speed is defined here to be the time it takes a Tetrimino to fall by one line. 
# The current level of the game determines the normal Fall Speed using the following equation:
# (0.8 - ((level - 1) * 0.007))^(level-1)
FALL_SPEED_LEVEL_1=1
FALL_SPEED_LEVEL_2=0.793
FALL_SPEED_LEVEL_3=0.618
FALL_SPEED_LEVEL_4=0.473
FALL_SPEED_LEVEL_5=0.355
FALL_SPEED_LEVEL_6=0.262
FALL_SPEED_LEVEL_7=0.190
FALL_SPEED_LEVEL_8=0.135
FALL_SPEED_LEVEL_9=0.094
FALL_SPEED_LEVEL_10=0.064
FALL_SPEED_LEVEL_11=0.043
FALL_SPEED_LEVEL_12=0.028
FALL_SPEED_LEVEL_13=0.018
FALL_SPEED_LEVEL_14=0.011
FALL_SPEED_LEVEL_15=0.007

# color codes
RED=1
GREEN=2
YELLOW=3
BLUE=4
MAGENTA=5
CYAN=6
WHITE=7
ORANGE=208

# Those are Tetrimino type
O_TETORIMINO=0
I_TETORIMINO=1
T_TETORIMINO=2
L_TETORIMINO=3
J_TETORIMINO=4
S_TETORIMINO=5
Z_TETORIMINO=6

# Those are the facing
# Tetorimino has four facings
NORTH=0
EAST=1
SOUTH=2
WEST=3

# Location and size of playfield, color and border
PLAYFIELD_W=10
PLAYFIELD_H=20
PLAYFIELD_X=30
PLAYFIELD_Y=2
BORDER_COLOR=$WHITE

# Location and color of score information
SCORE_X=1
SCORE_Y=10
SCORE_COLOR=$GREEN

SCORE_FACTOR_SINGLE=100
SCORE_FACTOR_DOUBLE=300
SCORE_FACTOR_TRIPLE=500
SCORE_FACTOR_TETRIS=800
SCORE_FACTOR_SOFTDROP=1
SCORE_FACTOR_HARDDROP=2

# Next piece location
NEXT_X=14
NEXT_Y=11
NEXT_MAX=7

# Location of 'game over' in the end of the game
GAMEOVER_X=$((PLAYFIELD_X + PLAYFIELD_W / 2))
GAMEOVER_Y=$((PLAYFIELD_Y + PLAYFIELD_H / 2))

# piece starting location
START_X=3
START_Y=22

# this array holds all possible pieces that can be used in the game
# each piece consists of 4 cells(minos)
# each string is sequence of relative xy coordinates

# O-Tetrimino
eval piece_"$O_TETORIMINO"_color=\"$YELLOW\"
eval piece_"$O_TETORIMINO"_minos_"$NORTH"=\'1 0 2 0 1 1 2 1\'
eval piece_"$O_TETORIMINO"_minos_"$EAST"=\'1 0 2 0 1 1 2 1\'
eval piece_"$O_TETORIMINO"_minos_"$SOUTH"=\'1 0 2 0 1 1 2 1\'
eval piece_"$O_TETORIMINO"_minos_"$WEST"=\'1 0 2 0 1 1 2 1\'

# I-Tetorimino
eval piece_"$I_TETORIMINO"_color=\"$CYAN\"
eval piece_"$I_TETORIMINO"_minos_"$NORTH"=\'0 1 1 1 2 1 3 1\'
eval piece_"$I_TETORIMINO"_minos_"$EAST"=\'2 0 2 1 2 2 2 3\'
eval piece_"$I_TETORIMINO"_minos_"$SOUTH"=\'0 2 1 2 2 2 3 2\'
eval piece_"$I_TETORIMINO"_minos_"$WEST"=\'1 0 1 1 1 2 1 3\'

# T-Tetorimino
eval piece_"$T_TETORIMINO"_color=\"$MAGENTA\"
eval piece_"$T_TETORIMINO"_minos_"$NORTH"=\'1 0 0 1 1 1 2 1\'
eval piece_"$T_TETORIMINO"_minos_"$EAST"=\'1 0 1 1 2 1 1 2\'
eval piece_"$T_TETORIMINO"_minos_"$SOUTH"=\'0 1 1 1 2 1 1 2\'
eval piece_"$T_TETORIMINO"_minos_"$WEST"=\'1 0 0 1 1 1 1 2\'

# L-Tetorimino
eval piece_"$L_TETORIMINO"_color=\"$ORANGE\"
eval piece_"$L_TETORIMINO"_minos_"$NORTH"=\'2 0 0 1 1 1 2 1\'
eval piece_"$L_TETORIMINO"_minos_"$EAST"=\'1 0 1 1 1 2 2 2\'
eval piece_"$L_TETORIMINO"_minos_"$SOUTH"=\'0 1 1 1 2 1 0 2\'
eval piece_"$L_TETORIMINO"_minos_"$WEST"=\'0 0 1 0 1 1 1 2\'

# J-Tetorimino
eval piece_"$J_TETORIMINO"_color=\"$BLUE\"
eval piece_"$J_TETORIMINO"_minos_"$NORTH"=\'0 0 0 1 1 1 2 1\'
eval piece_"$J_TETORIMINO"_minos_"$EAST"=\'1 0 2 0 1 1 1 2\'
eval piece_"$J_TETORIMINO"_minos_"$SOUTH"=\'0 1 1 1 2 1 2 2\'
eval piece_"$J_TETORIMINO"_minos_"$WEST"=\'1 0 1 1 0 2 1 2\'

# S-Tetorimino
eval piece_"$S_TETORIMINO"_color=\"$GREEN\"
eval piece_"$S_TETORIMINO"_minos_"$NORTH"=\'1 0 2 0 0 1 1 1\'
eval piece_"$S_TETORIMINO"_minos_"$EAST"=\'1 0 1 1 2 1 2 2\'
eval piece_"$S_TETORIMINO"_minos_"$SOUTH"=\'1 1 2 1 0 2 1 2\'
eval piece_"$S_TETORIMINO"_minos_"$WEST"=\'0 0 0 1 1 1 1 2\'

# Z-Tetorimino
eval piece_"$Z_TETORIMINO"_color=\"$RED\"
eval piece_"$Z_TETORIMINO"_minos_"$NORTH"=\"0 0 1 0 1 1 2 1\"
eval piece_"$Z_TETORIMINO"_minos_"$EAST"=\"2 0 1 1 2 1 1 2\"
eval piece_"$Z_TETORIMINO"_minos_"$SOUTH"=\"0 1 1 1 1 2 2 2\"
eval piece_"$Z_TETORIMINO"_minos_"$WEST"=\"1 0 0 1 1 1 0 2\"

no_color=true    # do we use color or not
showtime=true    # controller runs while this flag is true
empty_cell=' .'  # how we draw empty cell
filled_cell='[]' # how we draw filled cell

# the queue of the next tetoriminos to be placed.
# the reference says the next six tetrimonos should be shown.
next_queue=''

# the hold queue allows the player to hold a falling tetorimino for as long as they wish.
hold_queue=''

bag=''

score=0 # score variable initialization
level=1 # level variable initialization

current_tty=$(
  ps -p $$ | tail -n 1 | (
    set $(cat)
    printf "$2"
  )
)

# screen_buffer is variable, that accumulates all screen changes
# this variable is printed in controller once per game cycle
puts() {
  screen_buffer="$screen_buffer""$1"
}

# move cursor to (x,y) and print string
# (1,1) is upper left corner of the screen
xyprint() {
  puts "\033[${2};${1}H${3}"
}

show_cursor() {
  printf "\033[?25h"
}

hide_cursor() {
  printf "\033[?25l"
}

# foreground color
set_fg() {
  $no_color && return
  puts "\033[38;5;${1}m"
  # puts "\033[3${1}m"
}

# background color
set_bg() {
  $no_color && return
  puts "\033[48;5;${1}m"
  # puts "\033[4${1}m"
}

reset_colors() {
  puts "\033[0m"
}

set_bold() {
  puts "\033[1m"
}

# playfield is 2-dimensional array, data is stored as follows:
# a_{y,x}
#   x - 0, ..., (PLAYFIELD_W-1)
#   y - 0, ..., (PLAYFIELD_H-1), ..., (START_Y-1)
# each array element contains cell color value or -1 if cell is empty
redraw_playfield() {
  local x y xp yp field_cell

  y=0
  xp=$PLAYFIELD_X # don't need to set xp every cell, need on front of the line.
  while [ "$y" -lt "$PLAYFIELD_H" ]; do
    yp=$((PLAYFIELD_Y + PLAYFIELD_H - y - 1))
    xyprint $xp $yp '' # put the cursor on the front of line
    x=0
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      field_cell=$(eval echo \"\$playfield_"$y"_"$x"\")
      
      if [ "$field_cell" -eq -1 ]; then
        puts "$empty_cell"
      else
        set_fg "$field_cell"
        set_bg "$field_cell"
        puts "$filled_cell"
        reset_colors
      fi
      x=$((x + 1))
    done
    y=$((y + 1))
  done
}

update_score() {
  :
}

fill_bag() {
  bag=$(shuf -e $O_TETORIMINO $I_TETORIMINO $T_TETORIMINO $L_TETORIMINO $J_TETORIMINO $S_TETORIMINO $Z_TETORIMINO |
  (
    while read piece; do
      printf "$piece"' '
    done
  ))
}

#  the Tetrimino at the front of the line in the bag is placed at the end of the Next Queue
feed_next_queue() {
  local poped

  [ -z "$bag" ] && fill_bag       # if bag is empty, then fill the bag.
  set $(echo "$bag")
  poped="$1"; shift; bag="$*"     # pop the tetorimino
  next_queue="$next_queue $poped" # place tetorimino at the end of the Next Queue
}

get_next() {
  local next_piece

  set $(echo "$next_queue")
  next_piece="$1"; shift; next_queue="$*" # pop the next piece from the front of queue
  feed_next_queue                         # push tetorimino into queue; keep queue size

  #next piece becomes current
  current_piece="$next_piece"
  current_piece_rotation="$NORTH"

  # place current at the top of play field.
  current_piece_x="$START_X"
  current_piece_y="$START_Y"

  # check if piece can be placed at this location, if not - game over
  new_piece_location_ok $current_piece_x $current_piece_y || cmd_quit
  show_current


}

hold_tetorimino() {
  :
}

draw_piece() {
  # Arguments:
  #   1 - x, 2 - y, 3 - type, 4 - rotation, 5 - cell content, 6 - mask with playfield
  
  local posx posy type rotation content lx ly x y masked

  # at first, we should save arguments.
  posx="$1"; posy="$2"; type="$3"; rotation="$4"; content="$5"; masked="${6:-false}"
  shift $#

  # set minos coordinates.
  set $(eval echo \"\$piece_"$type"_minos_"$rotation"\")

  # loop through tetorimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    # relative coordinates are retrieved bassed on orientation and added to absolute coordinates
    lx=$1; ly=$2
    x=$((posx + lx * 2)) # the width of cell is 2 characters thick
    y=$((posy + ly))

    $masked                                     &&
    [ "$y" -ge "$PLAYFIELD_Y" ]                 &&
    [ "$y" -lt $((PLAYFIELD_Y + PLAYFIELD_H)) ] &&
    [ "$x" -ge "$PLAYFIELD_X" ]                 &&
    [ "$x" -lt $((PLAYFIELD_X + PLAYFIELD_W * 2)) ] && xyprint $x $y "$content" # draw mino within playfield
    
    shift 2
  done
}

draw_current() {
  # Arguments: 1 - string to draw single cell
  # factor 2 for x because each cell is 2 characters wide
  draw_piece $((PLAYFIELD_X + current_piece_x * 2)) $((PLAYFIELD_Y + PLAYFIELD_H - 1 - current_piece_y)) $current_piece $current_piece_rotation "$1" true
}

show_current() {
  local color
  eval color=\"\$piece_"$current_piece"_color\"
  set_fg "$color"
  set_bg "$color"
  draw_current "$filled_cell"
  reset_colors
}

clear_current() {
  draw_current "$empty_cell"
}

new_piece_location_ok() {
  # Arguments: 1 - new x coordinate of the piece, 2 - new y coordinate of the piece
  # test if piece can be moved to new location

  local x_test y_test x y lx ly field_cell

  x_test="$1"; y_test="$2" # at first, we should preserve the parameters ...
  shift $#                 # .. and we shift all.

  # set minos coordinates into parameters
  # $1 - x, $2 - y
  set $(eval echo \"\$piece_"$current_piece"_minos_"$current_piece_rotation"\")
  
  # loop through tetorimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    lx="$1"; ly="$2"
    x=$((x_test + lx)) # new x coordinate of piece cell
    y=$((y_test - ly)) # new y coordinate of piece cell

    [ "$y" -lt 0 ]              || 
    [ "$x" -lt 0 ]              || 
    [ "$x" -ge "$PLAYFIELD_W" ] && return 1 # false; check if we are out of the play field

    field_cell=$(eval echo \"\$playfield_"$y"_"$x"\")
    [ "$field_cell" != -1 ] && return 1    # false; check if location is already occupied
  
    shift 2 # shift to next minos coordinates
  done
  return 0
}

draw_border() {
  local x1 x2 y1 y2 i x y

  set_bold
  set_fg $BORDER_COLOR
  x1=$((PLAYFIELD_X - 1))               # 1 here is because border is 1 characters thick
  x2=$((PLAYFIELD_X + PLAYFIELD_W * 2)) # 2 here is because each cell on play field is 2 characters wide
  y1=$((PLAYFIELD_Y - 1))
  y2=$((PLAYFIELD_Y + PLAYFIELD_H))

  i=0
  while [ "$i" -lt "$PLAYFIELD_H" ]; do
    y=$((i + PLAYFIELD_Y))
    xyprint $x1 $y "│"
    xyprint $x2 $y "│"
    i=$((i + 1))
  done
  
  i=0
  while [ "$i" -lt "$PLAYFIELD_W" ]; do
    x=$((i * 2 + PLAYFIELD_X)) # 2 here is because each cell on play field is 2 characters width
    xyprint $x $y1 '──'
    xyprint $x $y2 '──'
    i=$((i + 1))
  done
  
  xyprint $x1 $y1 "┌"; xyprint $x2 $y1 "┐" # draw the corners
  xyprint $x1 $y2 "└"; xyprint $x2 $y2 "┘"

  reset_colors
}

toggle_color() {
  $no_color && no_color=false || no_color=true
  draw_border
  redraw_playfield
  draw_border
  redraw_playfield
  show_current
}

# this function updated occupied cells in playfield array after piece is dropped
flatten_playfield() {
  local color lx ly x y

  eval color=\"\$piece_"$current_piece"_color\"

  # set minos coordinates into parameters
  # $1 - x, $2 - y
  set $(eval echo \"\$piece_"$current_piece"_minos_"$current_piece_rotation"\")
  
  # loop through tetorimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    lx="$1"; ly="$2"
    x=$((current_piece_x + lx))
    y=$((current_piece_y - ly))
    eval playfield_"$y"_"$x"="$color"
    shift 2 # shift to next minos coordinates
  done
}

# this function goes through playfield array and eliminates lines without empty cells
process_complete_lines() {
  :
}

process_fallen_piece() {
  flatten_playfield
  process_complete_lines && return
  update_score $?
  redraw_playfield
}

move_piece() {
  # arguments: 1 - new x coordinate, 2 - new y coordinate
  # moves the piece to the new location if possible

  if new_piece_location_ok "$1" "$2"; then    # if new location is ok
    clear_current                             # let's wipe out piece current location
    current_piece_x="$1"                      # update x ...
    current_piece_y="$2"                      # ... and y of new location
    show_current                              # and draw piece in new location
    return 0                                  # nothing more to do here
  fi                                          # if we could not move piece to new location
  [ "$2" -eq "$current_piece_y" ] && return 0 # and this was not horizontal move
  process_fallen_piece                        # let's finalize this piece
  get_next                                    # and start the new one
  return 1
}

rotate_piece() {
  # arguments: 1 - rotation direction; 1: clockwise; -1: counter-clockwise
  local direction="$1" old_rotation new_rotation
  
  old_rotation=$current_piece_rotation                             # preserve current orientation
  new_rotation=$((old_rotation + direction + 4))
  new_rotation=$((new_rotation % 4))                               # calculate new orientation
  current_piece_rotation=$new_rotation                             # set orientation to new
  if new_piece_location_ok $current_piece_x $current_piece_y; then # check if new orientation is ok
    current_piece_rotation=$old_rotation                           # if yes - restore old rotation ...
    clear_current                                                  # ... clear piece image 
    current_piece_rotation=$new_rotation                           # ... set new orientation
    show_current                                                   # ... draw piece with new orientation
  else                                                             # if new orientation is not ok
    current_piece_rotation=$old_rotation                           # restore old orientation
  fi
}

cmd_right(){
  move_piece $((current_piece_x + 1)) "$current_piece_y"
}

cmd_left() {
  move_piece $((current_piece_x - 1)) "$current_piece_y"
}

cmd_fall() {
  move_piece "$current_piece_x" $((current_piece_y - 1))
}

cmd_soft_drop() {
  move_piece "$current_piece_x" $((current_piece_y - 1))
}

cmd_hard_drop() {
  # move piece all way down
  while move_piece $current_piece_x $((current_piece_y - 1)); do
    :
  done
}

cmd_rotate_cw() {
  rotate_piece 1
}

cmd_rotate_ccw() {
  rotate_piece -1
}

cmd_hold() {
  :
}

cmd_quit() {
  showtime=false                               # let's stop controller ...
  pkill -USR2 -t "$current_tty" ${0##*/}       # ... send SIGUSR2 to all script instances to stop forked process ...
  xyprint $GAMEOVER_X $GAMEOVER_Y 'Game Over!'
  echo "$screen_buffer"                        # ... and print final message
}

init() {
  local x y i

  # playfield is initialized with -1s (empty cells)
  # x of playfield - 0, ..., (PLAYFIELD_W-1)
  # y of playfield - 0, ..., (PLAYFIELD_H-1), ..., (START_Y)
  y=0
  while [ "$y" -le "$START_Y" ]; do
    x=0
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      eval playfield_"$y"_"$x"=-1
      x=$((x + 1))
    done
    y=$((y + 1))
  done

  # prepare next queue filled with NEXT_MAX tetorimino 
  i=0
  while [ "$i" -lt "$NEXT_MAX" ]; do
    feed_next_queue
    i=$((i + 1))
  done

  screen_buffer=''
  clear
  hide_cursor
  get_next
  toggle_color
}

# this function runs in separate process
# it sends DOWN commands to controller with appropriate delay
ticker() {
  # on SIGUSR2 this process should exit
  trap exit USR2
  # on SIGUSR1 fall speed should be increased, this happens during level ups
  trap 'level=$((level + 1))' USR1

  # the game level, which SIGUSR1 counts up.
  level=1

  while true ; do 
    echo $FALL
    eval sleep \"\$FALL_SPEED_LEVEL_$level\"
  done
}

# this function processes keyboard input
reader() {
  trap exit USR2 # this process exits on SIGUSR2
  trap '' USR1   # SIGUSR1 is ignored
  local key a='' b='' cmd esc_ch='1b'

  stty -echo # disable terminal local echo (echoback)
  while true ;do
    # read one key, and convert to hex value
    key=$(stty -icanon; dd ibs=1 count=1 2>/dev/null | od -An -tx1)
    cmd=''
    # echo "$a$b$key" # For debugging to check the input sequence.
    case "$a$b$key" in
      *"$esc_ch $esc_ch") # 2 escapes
        cmd=$QUIT
        ;;
      *"$esc_ch 5b 41")   # 'up-cursor'
        cmd=$ROTATE_CW
        ;;
      *"$esc_ch 5b 42")   # 'down-cursor'
        cmd=$SOFT_DROP
        ;;
      *"$esc_ch 5b 43")   # 'right-cursor'
        cmd=$RIGHT
        ;;
      *"$esc_ch 5b 44")   # 'left-cursor'
        cmd=$LEFT
        ;;
      *'20')              # ' '
        cmd=$HARD_DROP
        ;;
      *'63')              # 'c'
        cmd=$HOLD
        ;;
      *'78')              # 'x'
        cmd=$ROTATE_CW
        ;;
      *'7a')              # 'z'
        cmd=$ROTATE_CCW
        ;;
      *'43')              # 'C'
        cmd=$TOGGLE_COLOR
        ;;
      *'51')              # 'Q'
        cmd=$QUIT
        ;;
    esac
    a=$b   # preserve previous keys
    b=$key
    [ -n "$cmd" ] && echo "$cmd" # if not empty string
  done
}

controller() {
  # SIGUSR1 and SIGUSR2 are ignored
  trap '' USR1 USR2
  local cmd commands
  
  # initialization of commands array with appropriate functions
  eval commands_"$QUIT"=cmd_quit
  eval commands_"$RIGHT"=cmd_right
  eval commands_"$LEFT"=cmd_left
  eval commands_"$ROTATE_CW"=cmd_rotate_cw
  eval commands_"$ROTATE_CCW"=cmd_rotate_ccw
  eval commands_"$FALL"=cmd_fall
  eval commands_"$SOFT_DROP"=cmd_soft_drop
  eval commands_"$HARD_DROP"=cmd_hard_drop
  eval commands_"$HOLD"=cmd_hold
  eval commands_"$TOGGLE_COLOR"=toggle_color

  init
  # set_fg $ORANGE
  # set_bg $ORANGE
  # current_piece="$O_TETORIMINO"
  # current_piece_rotation="$NORTH"
  # current_piece_x=0
  # current_piece_y=0
  # show_current
  # put_piece 5 1 2 2 "$filled_cell"
  # reset_colors
  
  # draw_border
  # redraw_playfield
  # printf "$screen_buffer"
  # return

  while $showtime; do               # run while showtime variable is true, it is changed to false in cmd_quit function
    echo "$screen_buffer"           # output screen buffer ...
    screen_buffer=""                # ... and reset it 
    read cmd                        # read next command from stdout
    eval eval \"\$commands_"$cmd"\" # run command
  done
}

stty_g=`stty -g` # let's save terminal state

# output of ticker and reader is joined and piped into controller
(
  ticker & # ticker runs as separate process
  reader
)|(
  controller
)

sleep 1
wait

show_cursor
stty "$stty_g" # let's restore terminal state
